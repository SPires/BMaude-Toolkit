(mod GSL-PROTOCOL-MUTEX is
 	inc SIMPLIFIED-ABSTRACT-MACHINE-NOTATION .
	inc AMN-PARAMETERIZED-STRUCTURE .
	
 	sorts Protocol StateProcess .
 	subsort Protocol < Substitution . 
	subsort StateProcess < Variable .
 	
	op protocolMutex : IndexedSet -> Protocol .
 	ops stateP1 stateP2 stateP3 stateP4 stateP5 crit : -> StateProcess .
	
	var A : IndexedSet .
	var ph : PlaceHolder .
	
	eq protocolMutex(A) = 
	BEGIN (
		WHILE (true) DO (
			ANY ph
			WHERE bigOr(ph,A)
			THEN (
				PRE (element(ph,A) eq 0) THEN (element(ph,A) := s(0)) END
				OR
				PRE ((element(ph,A) eq s(0)) and (crit eq 0)) THEN ((element(ph,A) := s(s(0))) ; (crit := s(0))) END
				OR
				PRE (element(ph,A) eq s(s(0))) THEN ((element(ph,A) := 0) ; (crit := 0)) END
			) END
		) END
	)END .
endm)

(mod GSL-MUTEX-SATISFACTION is
	inc GSL-PROTOCOL-MUTEX . 
	inc SYMBOLIC-CHECKER .
	subsort Conf < State .

	ops idleP1? waitP1? critP1? : -> Prop .
	ops idleP2? waitP2? critP2? : -> Prop .
	ops idleP3? waitP3? critP3? : -> Prop .
	ops idleP4? waitP4? critP4? : -> Prop .
	ops idleP5? waitP5? critP5? : -> Prop .
	ops safety2 safety3 safety4 safety5 : -> Formula .
	var S : Substitution . 
	var N : GNat . 
	var STO : Store .

	eq S , (stateP1 |-> N) STO |= idleP1? = if (N == 0) then (true) else (false) fi [variant] .
	eq S , (stateP1 |-> N) STO |= waitP1? = if (N == s(0)) then (true) else (false) fi [variant] .
	eq S , (stateP1 |-> N) STO |= critP1? = if (N == s(s(0))) then (true) else (false) fi [variant] .
	
	eq S , (stateP2 |-> N) STO |= idleP2? = if (N == 0) then (true) else (false) fi [variant] .
	eq S , (stateP2 |-> N) STO |= waitP2? = if (N == s(0)) then (true) else (false) fi [variant] .
	eq S , (stateP2 |-> N) STO |= critP2? = if (N == s(s(0))) then (true) else (false) fi [variant] .
	
	eq S , (stateP2 |-> N) STO |= idleP3? = if (N == 0) then (true) else (false) fi [variant] .
	eq S , (stateP2 |-> N) STO |= waitP3? = if (N == s(0)) then (true) else (false) fi [variant] .
	eq S , (stateP2 |-> N) STO |= critP3? = if (N == s(s(0))) then (true) else (false) fi [variant] .
	
	eq S , (stateP2 |-> N) STO |= idleP4? = if (N == 0) then (true) else (false) fi [variant] .
	eq S , (stateP2 |-> N) STO |= waitP4? = if (N == s(0)) then (true) else (false) fi [variant] .
	eq S , (stateP2 |-> N) STO |= critP4? = if (N == s(s(0))) then (true) else (false) fi [variant] .
	
	eq S , (stateP2 |-> N) STO |= idleP5? = if (N == 0) then (true) else (false) fi [variant] .
	eq S , (stateP2 |-> N) STO |= waitP5? = if (N == s(0)) then (true) else (false) fi [variant] .
	eq S , (stateP2 |-> N) STO |= critP5? = if (N == s(s(0))) then (true) else (false) fi [variant] .
	
	eq safety2 = []~(critP1? /\ critP2?) .
	
	eq safety3 = []~((critP1? /\ critP2?) \/ (critP1? /\ critP3?) \/ (critP2? /\ critP3?)) .
	
	eq safety4 = []~((critP1? /\ critP2?) \/ (critP1? /\ critP3?) \/ (critP1? /\ critP4?) 
	\/ (critP2? /\ critP3?) \/ (critP2? /\ critP4?) \/ (critP3? /\ critP4?)) .
	
	eq safety5 = []~((critP1? /\ critP2?) \/ (critP1? /\ critP3?) \/ (critP1? /\ critP4?) \/ (critP1? /\ critP5?) 
	\/ (critP2? /\ critP3?) \/ (critP2? /\ critP4?) \/ (critP2? /\ critP5?) \/ (critP3? /\ critP4?) \/ 
	(critP3? /\ critP5?) \/ (critP4? /\ critP5?)) .
	
endm)

--- Safety property verification
(lmc protocolMutex((0,stateP1),(s(0),stateP2)), STO:Store |= safety2 .)
(lmc protocolMutex((0,stateP1),(s(0),stateP2),(s(s(0)),stateP3)), STO:Store |= safety3 .)
(lmc protocolMutex((0,stateP1),(s(0),stateP2),(s(s(0)),stateP3),(s(s(s(0))),stateP4)), STO:Store |= safety4 .)
(lmc protocolMutex((0,stateP1),(s(0),stateP2),(s(s(0)),stateP3),(s(s(s(0))),stateP4),(s(s(s(s(0)))),stateP5)), STO:Store |= safety5 .)
