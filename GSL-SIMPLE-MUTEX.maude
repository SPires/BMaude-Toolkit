***(
	Inserir cabeÃ§alho adequado
)

(mod GSL-PROTOCOL is
	inc SIMPLIFIED-ABSTRACT-MACHINE-NOTATION .
	op protocol : VariableSet -> Substitution .
	op process : -> PlaceHolder .
	ops crit stateP1 stateP2 stateP3 stateP4 stateP5 : -> Variable .
	var VS : VariableSet .
	eq protocol(VS) =
	BEGIN
		ANY process
		WHERE process in VS
		THEN
			PRE (process eq 0) THEN (process := s(0)) END
			OR
			PRE (process eq s(0)) THEN ((process := s(s(0)))) END
			OR
			PRE (process eq s(s(0))) THEN (process := 0) END
		END
	END .
endm)

(mod GSL-PROTOCOL-SATISFACTION is
	inc GSL-PROTOCOL .
	inc SYMBOLIC-CHECKER .
	subsort Conf < State .
	ops idleP1? idleP2? idleP3? idleP4? idleP5? : -> Prop .
	ops waitP1? waitP2? waitP3? waitP4? waitP5? : -> Prop . 
	ops critP1? critP2? critP3? critP4? critP5? : -> Prop . 
	
	var S : Substitution .
	vars N M : GNat .
	
	eq S , (stateP1 |-> N) STO:Store |= idleP1? = if (N == 0) then (true) else (false) fi [variant] .
	eq S , (stateP1 |-> N) STO:Store |= waitP1? = if (N == s(0)) then (true) else (false) fi [variant] .
	eq S , (stateP1 |-> N) STO:Store |= critP1? = if (N == s(s(0))) then (true) else (false) fi [variant] .
	
	eq S , (stateP2 |-> N) STO:Store |= idleP2? = if (N == 0) then (true) else (false) fi [variant] .
	eq S , (stateP2 |-> N) STO:Store |= waitP2? = if (N == s(0)) then (true) else (false) fi [variant] .
	eq S , (stateP2 |-> N) STO:Store |= critP2? = if (N == s(s(0))) then (true) else (false) fi [variant] .
	
	eq S , (stateP3 |-> N) STO:Store |= idleP3? = if (N == 0) then (true) else (false) fi [variant] .
	eq S , (stateP3 |-> N) STO:Store |= waitP3? = if (N == s(0)) then (true) else (false) fi [variant] .
	eq S , (stateP3 |-> N) STO:Store |= critP3? = if (N == s(s(0))) then (true) else (false) fi [variant] .
	
	eq S , (stateP4 |-> N) STO:Store |= idleP4? = if (N == 0) then (true) else (false) fi [variant] .
	eq S , (stateP4 |-> N) STO:Store |= waitP4? = if (N == s(0)) then (true) else (false) fi [variant] .
	eq S , (stateP4 |-> N) STO:Store |= critP4? = if (N == s(s(0))) then (true) else (false) fi [variant] .
	
	eq S , (stateP5 |-> N) STO:Store |= idleP5? = if (N == 0) then (true) else (false) fi [variant] .
	eq S , (stateP5 |-> N) STO:Store |= waitP5? = if (N == s(0)) then (true) else (false) fi [variant] .
	eq S , (stateP5 |-> N) STO:Store |= critP5? = if (N == s(s(0))) then (true) else (false) fi [variant] .
endm)

(lmc protocol({stateP1, stateP2}), STO:Store |= <> (critP4?) .)

(lmc protocol({stateP1, stateP2}), STO:Store |= [] ~(critP1? /\ critP2?) .)

(lmc protocol({stateP1, stateP2}), STO:Store |= [] ((waitP1? -> <> critP1?) \/ (waitP2? -> <> critP2?)) .)

(lmc protocol({stateP1, stateP2, stateP3}), STO:Store |= [] ~((critP1? /\ critP2?) \/ (critP1? /\ critP3?) \/ (critP2? /\ critP3?)) .)

(lmc protocol({stateP1, stateP2, stateP3}), STO:Store |= [] ((waitP1? -> <> critP1?) \/ (waitP2? -> <> critP2?) \/ (waitP3? -> <> critP3?)) .)

(lmc protocol({stateP1, stateP2, stateP3, stateP4}), STO:Store |= [] ~((critP1? /\ critP2?) \/ (critP1? /\ critP3?) \/ (critP1? /\ critP4?) \/ (critP2? /\ critP3?) \/ (critP2? /\ critP4?) \/ (critP3? /\ critP4?)) .)

(lmc protocol({stateP1, stateP2, stateP3, stateP4}), STO:Store |= [] ((waitP1? -> <> critP1?) \/ (waitP2? -> <> critP2?) \/ (waitP3? -> <> critP3?) \/ (waitP4? -> <> critP4?)) .)