load symbolic-checker

set verbose on .

(fmod GSL-VARIABLE is
	sort Variable PlaceHolder .
	subsort PlaceHolder < Variable .
endfm)

(fmod GNAT is 
	sort GNat .
	op 0 : -> GNat .
	op s : GNat -> GNat .
	op _+_ : GNat GNat -> GNat [assoc comm] .
	vars G G1 G2 : GNat .
	eq 0 + G = G .
	eq G1 + s(G2) = s(G1 + G2) .
endfm)

(fmod GSL-EXPRESSION is
	inc GNAT .
	inc GSL-VARIABLE .
	sort Expression .
	subsort GNat PlaceHolder Variable < Expression .
	subsort PlaceHolder < Expression .
	op _+_ : Expression Expression -> Expression [assoc comm] .	
endfm)

(fmod GBOOL is
	sort GBool .
	ops true false : -> GBool .
	op neg : GBool -> GBool .
	op _and_ : GBool GBool -> GBool [assoc comm] .
	vars G G1 G2 : GBool .
	eq neg(true) = false .
	eq neg(false) = true .
	eq true and G = G .
	eq false and G = false .
endfm)

--------------------------------------------------------------------------------------
(view Variable from TRIV to GSL-VARIABLE is
	sort Elt to Variable .
endv)
--------------------------------------------------------------------------------------

(fmod GSL-PREDICATE is 
	inc GBOOL . inc GSL-EXPRESSION .
	inc GSL-VARIABLE .	
	sort Predicate .
	subsort GBool PlaceHolder < Predicate < Expression .
	op neg : Predicate -> Predicate .
	op _and_ : Predicate Predicate -> Predicate [assoc comm] .		
	op _eq_ : Expression Expression -> Predicate [assoc comm] .
	vars G1 G2 : GNat .
	eq G1 eq G2 = if (G1 == G2) then true else false fi .
	--------------------------------------------------------------------------------------
	inc LIST{Variable}*(op __ to _`,_ ) .
	sort VariableSet .
	subsort Variable < NeList{Variable} .
	op `{_`} : NeList{Variable} -> VariableSet .
	op _in_ : Variable VariableSet -> Predicate .
	vars V1 V2 : Variable .
	var VS : NeList{Variable} .
	eq V1 in {V2} = if (V1 == V2) then true else false fi .
	eq V1 in { V2, VS } = if (V1 == V2) then true else (V1 in {VS}) fi .
	---------------------------------------------------------------------------------------
endfm)

(fmod GSL-SYNTAX is
	inc GSL-EXPRESSION . 
	inc GSL-PREDICATE .
	
	sort Substitution UChoice .
	subsort Variable < Expression Predicate .
	subsort UChoice < Substitution .
	
	--- Simple substitution
	op _:=_ : Variable Expression -> Substitution [ctor] .

	--- "Does nothing" substitution
	op skip : -> Substitution [ctor] .

	--- Pre-condition substitution
	op _|_ : Predicate Substitution -> Substitution [ctor] .

	--- Bounded choice substitution
	op _`[`]_ : Substitution Substitution -> Substitution [assoc comm ctor] .

	--- Guarded substitution
	op _==>_ : Predicate Substitution -> Substitution [ctor] .

	--- Unbounded choice substitution
	op @_._ : PlaceHolder Substitution -> UChoice [ctor] .
endfm)

(fmod GSL-STORE is 
	inc GSL-VARIABLE .
	inc GNAT .
	
	sorts Cell Store .
	subsort Cell < Store .
	
	op _|->_ : Variable GNat -> Cell .

	op empty : -> Store .
	op __ : Store Store -> Store [assoc comm id: empty] .

	var V : Variable . var G : GNat . var S : Store .

	eq (V |-> G)  (V |-> G)  S = (V |-> G)  S .
endfm)

--------------------------------------------------------------------------------------
(view Substitution from TRIV to GSL-SYNTAX is
sort Elt to Substitution .
endv)
--------------------------------------------------------------------------------------

(mod GSL-SEMANTICS is
	inc GSL-SYNTAX .
	inc GSL-STORE .
	
	sort Conf .

	op abort : -> Conf .
	
	op _`,_ : Substitution Store -> Conf .
	op _`,_`,_ : Predicate Substitution Store -> Conf [frozen] .
	op _`,_`,_ : Expression Substitution Store -> Conf [frozen] .
	op _`[_/_`] : Expression GNat PlaceHolder -> Expression .
	op _`[_/_`] : Expression GBool PlaceHolder -> Expression .
	op _`[_/_`] : Predicate GNat PlaceHolder -> Predicate .
	op _`[_/_`] : Predicate GBool PlaceHolder -> Predicate .
	op _`[_/_`] : Substitution GNat PlaceHolder -> Substitution .
	op _`[_/_`] : Substitution GBool PlaceHolder -> Substitution .
	--------------------------------------------------------------------------------------
	op _`[_/_`] : Expression Variable PlaceHolder -> Expression .	
	op _`[_/_`] : Predicate Variable PlaceHolder -> Predicate .	
	op _`[_/_`] : Substitution Variable PlaceHolder -> Substitution .
	--------------------------------------------------------------------------------------	

	var V V1 V2 : Variable . vars E E1 E2 : Expression . var STO STO' : Store . vars G G1 G2 : GNat .
	var P : Predicate . vars S S1 S2 : Substitution . var PH : PlaceHolder . var B B1 B2 : GBool .
	
***(-----------------------------------------------------------------------------------	
	inc LIST{Substitution} .
	op _`,_`,_ : List{Substitution} Substitution Store -> Conf [frozen] .
	op _||_ : Substitution Substitution -> Substitution [id: skip] .
	op `[_/_`] : Expression Variable -> Substitution .
	var SL : List{Substitution} .
	eq [paralel1] : (((V := G) || S) , STO) = (([G / V]) , (S) , (STO)) [variant] .
	eq [paralel1] : (((V := V1) || S) , ((V1 |-> G) STO)) = (([G / V]) , (S) , (STO)) [variant] .
	eq [paralel2] : ((SL) , (((V := G) || S)) , (STO)) = (( SL [G / V] ) , (S) , (STO)) [variant] .
	--------------------------------------------------------------------------------------)
	
	eq [simple1] : ((V := E) , STO) = (E, (V := E) , STO)  [variant] .
	eq [simple2] : (V1, (V2 := E) , ((V1 |-> G) STO)) = (G, (V2 := E) , ((V1 |-> G) STO)) [variant] .
	eq [simple2] : (V1 + E1, (V2 := E2) , ((V1 |-> G) STO)) = (G + E1, (V2 := E2) , ((V1 |-> G) STO)) [variant] .
	eq [simple2] : (G1, (V := E) , ((V |-> G2) STO)) = (skip , ((V |-> G1) STO)) [variant] .

	eq [pre1] : ((P | S) , STO) = (P , (P | S) , STO) [variant] .
	eq [pre2] : (V1 eq E, (P | S) , ((V1 |-> G) STO)) = (G eq E, (P | S) , ((V1 |-> G) STO)) [variant] .
	eq [pre3] : (true, (P | S) , STO) = (S , STO) [variant] .
	eq [pre4] : (false, (P | S) , STO) = abort [variant] .

	rl [bchoice] : S1 [] S2 => S1 .

	eq [guard1] : (P ==> S , STO) = (P , (P ==> S) , STO) [variant] .
	eq [guard2] : ((V1 eq E), (P ==> S) , ((V1 |-> G) STO)) = ((G eq E), (P ==> S) , ((V1 |-> G) STO)) [variant] .
	eq [guard3] : (true, (P ==> S) , STO) = (S , STO) [variant] .
	eq [guard4] : (false, (P ==> S) , STO) = (skip, STO) [variant] .
---***(
	rl [uchoice] : (@ PH . S), STO => (S [ G / PH ]), STO [nonexec] .
	rl [uchoice] : (@ PH . S), STO => (S [ B / PH ]), STO [nonexec] .
	--------------------------------------------------------------------------------------
	rl [uchoice] : (@ PH . S), STO => (S [ V / PH ]), STO [nonexec] .
	--------------------------------------------------------------------------------------  	
	
	--- Equations for _[_/_]
	--- We assume that alpha-renaming has been performed.
	eq [repl-gnat] : G1 [ G2 / PH ] = G1 .
	eq [repl-gnat] : G [ B / PH ] = B .
	eq [repl-gbool1] : B1 [ B2 / PH ] = B1 .
	eq [repl-gbool2] : B [ G / PH ] = B .	
	eq [repl-simple] : (V := E) [ G / PH ] = V := ( E [ G / PH ] ) .
	eq [repl-simple] : (V := E) [ B / PH ] = V := ( E [ B / PH ] ) .	
	eq [repl-guarded-subst] : (P ==> S) [ G / PH ] = ((P [ G / PH ]) ==> (S [ G / PH])) .
	eq [repl-guarded-subst] : (P ==> S) [ B / PH ] = ((P [ B / PH ]) ==> (S [ B / PH])) .	
	eq [repl-guarded-subst] : (P | S) [ G / PH ] = ((P [ G / PH ]) | (S [ G / PH])) .
	eq [repl-guarded-subst] : (P | S) [ B / PH ] = ((P [ B / PH ]) | (S [ B / PH])) .	
	eq [repl-ph-gnat] : PH [ G / PH ] = G .
	eq [repl-ph-gbool] : PH [ B / PH ] = B .
	eq [repl-and] : (PH and P) [ B / PH ] = B and (P [ B / PH]) .
	eq [repl-ph-sum] : (PH + E) [ G / PH ] = G + (E [ G / PH ]) .
	--------------------------------------------------------------------------------------Revisar aqui
	eq [repl-gnat] : G [ V / PH ] = G .	
	eq [repl-gbool2] : B [ V / PH ] = B .	
	eq [repl-variable] : V [ B / PH ] = if (PH == V) then (B) else (V) fi .			
	eq [repl-variable] : V [ G / PH ] = if (PH == V) then (G) else (V) fi .	
	eq [repl-variable] : V1 [ V2 / PH ] = if (PH == V1) then (V2) else (V1) fi .	
	eq [repl-simple] : (V := E) [ V1 / PH ] = V1 := ( E [ V1 / PH ] ) .			
	eq [repl-guarded-subst] : (P ==> S) [ V / PH ] = ((P [ V / PH ]) ==> (S [ V / PH])) .			
	eq [repl-prec-subst] : (P | S) [ V / PH ] = ((P [ V / PH ]) | (S [ V / PH])) .			
	eq [repl-ph-gbool] : PH [ V / PH ] = V .	
	eq [repl-ph-sum] : (PH + E) [ V / PH ] = V + (E [ V / PH ]) .	
	eq [repl-ph-in] : (PH in VS:VariableSet) [ V / PH ] = V in VS:VariableSet .
	--------------------------------------------------------------------------------------)
endm)

(mod SIMPLIFIED-ABSTRACT-MACHINE-NOTATION is
    inc GSL-SEMANTICS .
	sort NeSubstitutionSet .
	subsort Substitution < NeSubstitutionSet .

	op BEGIN_END : Substitution -> Substitution .
	op PRE_THEN_END : Predicate Substitution -> Substitution .
	op IF_THEN_ELSE_END : Predicate Substitution Substitution -> Substitution .
	op IF_THEN_END : Predicate Substitution -> Substitution .
	op _:=`bool`(_`) : Variable Predicate -> Substitution .
	op _OR_ : NeSubstitutionSet NeSubstitutionSet -> NeSubstitutionSet [assoc comm] .
	op CHOICE_END : NeSubstitutionSet -> Substitution .
	op ANY_WHERE_THEN_END : PlaceHolder Predicate Substitution -> Substitution .

	vars S T : Substitution . var SS : NeSubstitutionSet . var P : Predicate . var X : PlaceHolder .

	eq BEGIN S END = S .
	eq PRE P THEN S END = P | S .
	eq IF P THEN S ELSE T END = (P ==> S) [] (neg(P) ==> S) .
	eq IF P THEN S END = IF P THEN S ELSE skip END .
	eq X := bool ( P ) = IF P THEN (X := true) ELSE (X := false) END .
	eq CHOICE SS END = SS .
	eq S OR T = S [] T .	
	eq S OR (T OR SS) = S [] (T OR SS) .
	eq ANY X WHERE P THEN S END = (@ X . (P ==> S)) .	
endm)

(mod GSL-PROTOCOL is
	inc SIMPLIFIED-ABSTRACT-MACHINE-NOTATION .
	op protocol : VariableSet -> Substitution .
	op process : -> PlaceHolder .
	ops crit stateP1 stateP2 stateP3 stateP4 stateP5 : -> Variable .
	var VS : VariableSet .
	eq protocol(VS) =
	BEGIN
		ANY process
		WHERE process in VS
		THEN
			PRE (process eq 0) THEN (process := s(0)) END
			OR
			PRE (process eq s(0)) THEN ((process := s(s(0)))) END
			OR
			PRE (process eq s(s(0))) THEN (process := 0) END
		END
	END .
endm)

(mod GSL-PROTOCOL-SATISFACTION is
	inc GSL-PROTOCOL .
	inc SYMBOLIC-CHECKER .
	subsort Conf < State .
	ops idleP1? idleP2? idleP3? idleP4? idleP5? : -> Prop .
	ops waitP1? waitP2? waitP3? waitP4? waitP5? : -> Prop . 
	ops critP1? critP2? critP3? critP4? critP5? : -> Prop . 
	
	var S : Substitution .
	vars N M : GNat .
	
	eq S , (stateP1 |-> N) STO:Store |= idleP1? = if (N == 0) then (true) else (false) fi [variant] .
	eq S , (stateP1 |-> N) STO:Store |= waitP1? = if (N == s(0)) then (true) else (false) fi [variant] .
	eq S , (stateP1 |-> N) STO:Store |= critP1? = if (N == s(s(0))) then (true) else (false) fi [variant] .
	
	eq S , (stateP2 |-> N) STO:Store |= idleP2? = if (N == 0) then (true) else (false) fi [variant] .
	eq S , (stateP2 |-> N) STO:Store |= waitP2? = if (N == s(0)) then (true) else (false) fi [variant] .
	eq S , (stateP2 |-> N) STO:Store |= critP2? = if (N == s(s(0))) then (true) else (false) fi [variant] .
	
	eq S , (stateP3 |-> N) STO:Store |= idleP3? = if (N == 0) then (true) else (false) fi [variant] .
	eq S , (stateP3 |-> N) STO:Store |= waitP3? = if (N == s(0)) then (true) else (false) fi [variant] .
	eq S , (stateP3 |-> N) STO:Store |= critP3? = if (N == s(s(0))) then (true) else (false) fi [variant] .
	
	eq S , (stateP4 |-> N) STO:Store |= idleP4? = if (N == 0) then (true) else (false) fi [variant] .
	eq S , (stateP4 |-> N) STO:Store |= waitP4? = if (N == s(0)) then (true) else (false) fi [variant] .
	eq S , (stateP4 |-> N) STO:Store |= critP4? = if (N == s(s(0))) then (true) else (false) fi [variant] .
	
	eq S , (stateP5 |-> N) STO:Store |= idleP5? = if (N == 0) then (true) else (false) fi [variant] .
	eq S , (stateP5 |-> N) STO:Store |= waitP5? = if (N == s(0)) then (true) else (false) fi [variant] .
	eq S , (stateP5 |-> N) STO:Store |= critP5? = if (N == s(s(0))) then (true) else (false) fi [variant] .
endm)

(lmc protocol({stateP1, stateP2}), STO:Store |= <> (critP4?) .)

(lmc protocol({stateP1, stateP2}), STO:Store |= [] ~(critP1? /\ critP2?) .)

(lmc protocol({stateP1, stateP2}), STO:Store |= [] ((waitP1? -> <> critP1?) \/ (waitP2? -> <> critP2?)) .)

(lmc protocol({stateP1, stateP2, stateP3}), STO:Store |= [] ~((critP1? /\ critP2?) \/ (critP1? /\ critP3?) \/ (critP2? /\ critP3?)) .)

(lmc protocol({stateP1, stateP2, stateP3}), STO:Store |= [] ((waitP1? -> <> critP1?) \/ (waitP2? -> <> critP2?) \/ (waitP3? -> <> critP3?)) .)

(lmc protocol({stateP1, stateP2, stateP3, stateP4}), STO:Store |= [] ~((critP1? /\ critP2?) \/ (critP1? /\ critP3?) \/ (critP1? /\ critP4?) \/ (critP2? /\ critP3?) \/ (critP2? /\ critP4?) \/ (critP3? /\ critP4?)) .)

(lmc protocol({stateP1, stateP2, stateP3, stateP4}), STO:Store |= [] ((waitP1? -> <> critP1?) \/ (waitP2? -> <> critP2?) \/ (waitP3? -> <> critP3?) \/ (waitP4? -> <> critP4?)) .)