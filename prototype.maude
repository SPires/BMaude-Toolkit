load symbolic-checker .
set verbose on .

(fmod GSL-VARIABLE is
	sort Variable PlaceHolder .
endfm)

(fmod GNAT is 
	sort GNat .
	op 0 : -> GNat .
	op s : GNat -> GNat [iter] .
	op _+_ : GNat GNat -> GNat [assoc comm] .
	op _-_ : GNat GNat -> GNat .
	op _x_ : GNat GNat -> GNat [assoc comm] .

	vars G G1 G2 : GNat .
	eq 0 + G = G .
	eq G1 + s(G2) = s(G1 + G2) .
	
	eq G1 - 0 = G1 .
	eq 0 - G1 = G1 .
	eq s(G1) - s(G2) = G1 - G2 .
	
	eq 0 x G1 = 0 .
	eq s(0) x G1 = G1 .
	eq G1 x s(G2) = G1 + (G1 x G2) .
endfm)

(fmod GBOOL is
	sort GBool .
	ops true false : -> GBool .
	op neg : GBool -> GBool .
	op _and_ : GBool GBool -> GBool [assoc comm] .
	op _or_ : GBool GBool -> GBool [assoc comm] .
	vars B B1 B2 : GBool .
	eq neg(true) = false .
	eq neg(false) = true .
	eq true and B = B .
	eq false and B = false .
	eq true or B = true .
	eq false or B = B .
endfm)

(fmod GSL-SYMBOL is
	sort GSym .
endfm)

(fmod GSL-EXPRESSION is
	inc GNAT .
	inc GSL-VARIABLE .
	sort Expression .
	subsort GNat PlaceHolder < Expression .
	op _+_ : Expression Expression -> Expression [assoc comm] .
	op _-_ : Expression Expression -> Expression .
	op _x_ : Expression Expression -> Expression [assoc comm] .
endfm)

(view Naturals from DEFAULT to GNAT is
	sort Elt to GNat .
endv)

(view Natural from TRIV to GNAT is
	sort Elt to GNat .
endv)

(view Variable from TRIV to GSL-VARIABLE is
	sort Elt to Variable .
endv)

(fmod GSL-ARRAYS is
	inc ARRAY{Variable,Naturals}*(op _|->_ to _`,_) .
	inc GSL-EXPRESSION .
	---op _`(_`) : Array{Variable,Naturals} GNat -> Variable .
	op _`(_`) : Array{Variable,Naturals} Expression -> Variable .
	op gn : PlaceHolder -> GNat .
	op nullVar : -> Variable .
	vars X Y : Variable . vars G1 G2 : GNat . var A : Array{Variable,Naturals} .
	ceq (X,G1) ; (Y, G2) ; A = ((X,G1) ; A) if (G1 == G2) .
	eq ((X,G1) ; A)(G1) = X .
	eq ((X,G1) ; A)(G2) = nullVar [owise] .
endfm)

(fmod GSL-PREDICATE is 
	inc GBOOL .
	inc GSL-SYMBOL . 
	inc GSL-EXPRESSION .
	inc SET{Natural}*(op _in_ to _belong_) . 
	inc GSL-ARRAYS .
	sort Predicate .
	subsort GSym < Expression .
	subsort GBool PlaceHolder < Predicate < Expression .
	
	op neg : Predicate -> Predicate .
	op _and_ : Predicate Predicate -> Predicate [assoc comm] .		
	op _eq_ : Expression Expression -> Predicate [assoc comm] .
	op _or_ : Predicate Predicate -> Predicate [assoc comm] .
	op _>_ : Expression Expression -> Predicate .
	op _>=_ : Expression Expression -> Predicate .
	op _<_ : Expression Expression -> Predicate .
	op _<=_ : Expression Expression -> Predicate .
	op _in_ : Expression Set{Natural} -> Predicate .
	op _in_ : Expression Array{Variable,Naturals} -> Predicate .
	
	vars G1 G2 : GNat . var GS : Set{Natural} . vars Y1 Y2 : GSym .
	var V : Variable . var A : Array{Variable,Naturals} .
	
	eq G1 eq G2 = if (G1 == G2) then true else false fi .
	eq Y1 eq Y2 = if (Y1 == Y2) then true else false fi .
	
	eq 0 > G1 = false .
	eq G1 > 0 = if (G1 =/= 0) then true else false fi .
	eq s(G1) > s(G2) = G1 > G2 .
	
	eq 0 >= G1 = if (G1 == 0) then true else false fi .
	eq G1 >= 0 = true .
	eq s(G1) >= s(G2) = G1 >= G2 .
	
	eq 0 < G1 = if (G1 == 0) then false else true fi .
	eq G1 < 0 = false .
	eq s(G1) < s(G2) = G1 < G2 .
	
	eq 0 <= G1 = true .
	eq G1 <= 0 = if (G1 == 0) then true else false fi .
	eq s(G1) <= s(G2) = G1 <= G2 .
	
	eq G1 in (G1,GS) = true .
	eq G1 in GS = false [owise] .
	
	eq G1 in ((V,G1) ; A) = true .
	eq G1 in A = false [owise] .
endfm)

(fmod GSL-CONVERSION is

***(

	Coercion functions

	In B, a variable can be an expression and part of a predicate.
	The multiple assignment causes issues with the subsort relation
	Variable < Predicate < Expression.

	The use of lists in order to implement this operator causes troubles to Maude.
	Once a Variable is an Expression, a list of variables is a list of expressions.
	In order to avoid this problem, we need to use this functions.
)

	inc GSL-VARIABLE . inc GSL-EXPRESSION . inc GSL-PREDICATE .
	op exp : Variable -> Expression .
	op pre : Variable -> Predicate .
endfm)

(fmod GSL-LISTS is
	inc GSL-VARIABLE .
	inc GSL-EXPRESSION .
	sorts VarList ExpList .
	subsort Variable < VarList .
	subsort Expression < ExpList .

***(
	
	Unification issues
	
	The current version of Maude System doesn't support unification of 
	operators with the associativity axiom without the commutativity axiom. 
	Unification over associativity isn't a finitary procedure.
)
	
	op __ : Variable VarList -> VarList .
	op __ : Expression ExpList -> ExpList .
endfm)

(fmod GSL-SYNTAX is
	inc GSL-EXPRESSION . 
	inc GSL-PREDICATE .
	inc GSL-LISTS .
	inc GSL-CONVERSION .
	
	sort Substitution UChoice .
	subsort UChoice < Substitution .
	
	--- Multiple and Simple substitutions
	op _:=_ : VarList ExpList -> Substitution [ctor] .
	op _:=_ : Variable Expression -> Substitution [ctor] .

	--- "Does nothing" substitution
	op skip : -> Substitution [ctor] .

	--- Pre-condition substitution
	op _|_ : Predicate Substitution -> Substitution [ctor] .

	--- Bounded choice substitution
	op _`[`]_ : Substitution Substitution -> Substitution [assoc comm ctor] .

	--- Guarded substitution
	op _==>_ : Predicate Substitution -> Substitution [ctor] .

	--- Unbounded choice substitution
	op @_._ : PlaceHolder Substitution -> UChoice [ctor] .
	
	--- Loop Substitution
	op _^ : Substitution -> Substitution [ctor] .
	
	--- Sequential composition
	op _;_ : Substitution Substitution -> Substitution [strat(1 0) ctor] .
endfm)

(fmod GSL-STORE is 
	inc GSL-VARIABLE . inc GNAT .
	inc GBOOL . inc GSL-SYMBOL .
	
	sorts Cell Store .
	subsort Cell < Store .
	
	op _|->_ : Variable GNat -> Cell .
	op _|->_ : Variable GBool -> Cell .
	op _|->_ : Variable GSym -> Cell .

	op empty : -> Store .
	op __ : Store Store -> Store [assoc comm id: empty] .

	var V : Variable . var G : GNat . var S : Store . var B : GBool . var Y : GSym .

	--- Idempotency rules
	eq (V |-> G)  (V |-> G)  S = (V |-> G)  S .
	eq (V |-> B)  (V |-> B)  S = (V |-> B)  S .
	eq (V |-> Y)  (V |-> Y)  S = (V |-> Y)  S .
	
	--- Preference of types
	--- There are no two variables with the same name and different types.
	eq (V |-> G) (V |-> Y) S = (V |-> G) S .
	eq (V |-> G) (V |-> B) S = (V |-> G) S .
	eq (V |-> Y) (V |-> B) S = (V |-> Y) S .
endfm)

(mod GSL-SEMANTICS is
	inc GSL-SYNTAX .
	inc GSL-STORE .
	
	sort Conf .

	op abort : -> Conf .
	
	op _`,_ : Substitution Store -> Conf .
	op _`,_`,_ : Predicate Substitution Store -> Conf [frozen] .
	op _`,_`,_ : Expression Substitution Store -> Conf [frozen] .
	op _`[_/_`] : Expression GNat PlaceHolder -> Expression .
	op _`[_/_`] : Expression GBool PlaceHolder -> Expression .
	op _`[_/_`] : Predicate GNat PlaceHolder -> Predicate .
	op _`[_/_`] : Predicate GBool PlaceHolder -> Predicate .
	op _`[_/_`] : Substitution GNat PlaceHolder -> Substitution .
	op _`[_/_`] : Substitution GBool PlaceHolder -> Substitution .
	op _`[_/_`] : Variable GNat PlaceHolder -> Variable .
	op `[_|_`] : Substitution Store -> Substitution .
	
	vars V V1 V2 : Variable . vars E E1 E2 : Expression . vars STO STO' : Store . vars G G1 G2 : GNat .
	vars P P1 P2 : Predicate . vars S S1 S2 : Substitution . var PH : PlaceHolder . vars B B1 B2 : GBool .
	var VL : VarList . var EL : ExpList . vars Y Y1 Y2 : GSym . var SN : Set{Natural} .
	var A : Array{Variable,Naturals} .
	
	eq [multi1] : (((V VL := E EL) ; S) , STO) = (E, ([ (V VL := E EL) | STO ] ; S) , STO) [variant] .
	eq [multi1] : (([ (V VL := E EL) | STO ] ; S) , STO') = (E, ([ (V VL := E EL) | STO ] ; S) , STO') [variant] .
	eq [multi2] : (exp(V1), ([ (V VL := E EL) | (V1 |-> G1) STO ] ; S) , STO') = (G1, ([ (V VL := E EL) | (V1 |-> G1) STO ] ; S) , STO') [variant] .
	eq [multi2] : (exp(V1), ([ (V VL := E EL) | (V1 |-> B1) STO ] ; S) , STO') = (B1, ([ (V VL := E EL) | (V1 |-> B1) STO ] ; S) , STO') [variant] .
	eq [multi2] : (exp(V1), ([ (V VL := E EL) | (V1 |-> Y1) STO ] ; S) , STO') = (Y1, ([ (V VL := E EL) | (V1 |-> Y1) STO ] ; S) , STO') [variant] .
	eq [multi2] : (exp(V1) + E1, ([ (V VL := E EL) | (V1 |-> G1) STO ] ; S) , STO') = (G1 + E1, ([ (V VL := E EL) | (V1 |-> G1) STO ] ; S) , STO') [variant] .
	eq [multi2] : (exp(V1) x E1, ([ (V VL := E EL) | (V1 |-> G1) STO ] ; S) , STO') = (G1 x E1, ([ (V VL := E EL) | (V1 |-> G1) STO ] ; S) , STO') [variant] .
	eq [multi2] : (exp(V1) - E1, ([ (V VL := E EL) | (V1 |-> G1) STO ] ; S) , STO') = (G1 - E1, ([ (V VL := E EL) | (V1 |-> G1) STO ] ; S) , STO') [variant] .
	eq [multi2] : (E1 - exp(V1), ([ (V VL := E EL) | (V1 |-> G1) STO ] ; S) , STO') = (E1 - G1, ([ (V VL := E EL) | (V1 |-> G1) STO ] ; S) , STO') [variant] .
	eq [multi2] : (exp(V1) eq E1, ([ (V VL := E EL) | (V1 |-> G1) STO ] ; S) , STO') = (G1 eq E1, ([ (V VL := E EL) | (V1 |-> G1) STO ] ; S) , STO') [variant] .
	eq [multi2] : (exp(V1) eq E1, ([ (V VL := E EL) | (V1 |-> Y1) STO ] ; S) , STO') = (Y1 eq E1, ([ (V VL := E EL) | (V1 |-> Y1) STO ] ; S) , STO') [variant] .
	eq [multi3] : (G1, ([ (V VL := E EL) | STO ] ; S) , (V |-> G2) STO') = (([ (VL := EL) | STO ] ; S) , (V |-> G1) STO') [variant] .
	eq [multi3] : (G1, ([ (V := E) | STO ] ; S) , (V |-> G2) STO') = (([ skip | STO ] ; S) , (V |-> G1) STO') [variant] .
	eq [multi3] : (B1, ([ (V VL := E EL) | STO ] ; S) , (V |-> B2) STO') = (([ (VL := EL) | STO ] ; S) , (V |-> B1) STO') [variant] .
	eq [multi3] : (B1, ([ (V := E) | STO ] ; S) , (V |-> B2) STO') = (([ skip | STO ] ; S) , (V |-> B1) STO') [variant] .
	eq [multi3] : (Y1, ([ (V VL := E EL) | STO ] ; S) , (V |-> Y2) STO') = (([ (VL := EL) | STO ] ; S) , (V |-> Y1) STO') [variant] .
	eq [multi3] : (Y1, ([ (V := E) | STO ] ; S) , (V |-> Y2) STO') = (([ skip | STO ] ; S) , (V |-> Y1) STO') [variant] .
	eq [multi4] : (([ skip | STO ] ; S), STO') = (S, STO') [variant] .
	
	eq [multi1] : ((V VL := E EL) , STO) = (E, [ (V VL := E EL) | STO ] , STO) [variant] .
	eq [multi1] : ([ (V VL := E EL) | STO ] , STO') = (E, [ (V VL := E EL) | STO ] , STO') [variant] .
	eq [multi2] : (exp(V1), [ (V VL := E EL) | (V1 |-> G1) STO ] , STO') = (G1, [ (V VL := E EL) | (V1 |-> G1) STO ] , STO') [variant] .
	eq [multi2] : (exp(V1), [ (V VL := E EL) | (V1 |-> B1) STO ] , STO') = (B1, [ (V VL := E EL) | (V1 |-> B1) STO ] , STO') [variant] .
	eq [multi2] : (exp(V1), [ (V VL := E EL) | (V1 |-> Y1) STO ] , STO') = (Y1, [ (V VL := E EL) | (V1 |-> Y1) STO ] , STO') [variant] .
	eq [multi2] : (exp(V1) + E1, [ (V VL := E EL) | (V1 |-> G1) STO ] , STO') = (G1 + E1, [ (V VL := E EL) | (V1 |-> G1) STO ] , STO') [variant] .
	eq [multi2] : (exp(V1) x E1, [ (V VL := E EL) | (V1 |-> G1) STO ] , STO') = (G1 x E1, [ (V VL := E EL) | (V1 |-> G1) STO ] , STO') [variant] .
	eq [multi2] : (exp(V1) - E1, [ (V VL := E EL) | (V1 |-> G1) STO ] , STO') = (G1 - E1, [ (V VL := E EL) | (V1 |-> G1) STO ] , STO') [variant] .
	eq [multi2] : (E1 - exp(V1), [ (V VL := E EL) | (V1 |-> G1) STO ] , STO') = (E1 - G1, [ (V VL := E EL) | (V1 |-> G1) STO ] , STO') [variant] .
	eq [multi2] : (exp(V1) eq E1, [ (V VL := E EL) | (V1 |-> G1) STO ] , STO') = (G1 eq E1, [ (V VL := E EL) | (V1 |-> G1) STO ] , STO') [variant] .
	eq [multi2] : (exp(V1) eq E1, [ (V VL := E EL) | (V1 |-> Y1) STO ] , STO') = (Y1 eq E1, [ (V VL := E EL) | (V1 |-> Y1) STO ] , STO') [variant] .
	eq [multi3] : (G1, [ (V VL := E EL) | STO ] , (V |-> G2) STO') = ([ (VL := EL) | STO ] , (V |-> G1) STO') [variant] .
	eq [multi3] : (G1, [ (V := E) | STO ] , (V |-> G2) STO') = ([ skip | STO ] , (V |-> G1) STO') [variant] .
	eq [multi3] : (B1, [ (V VL := E EL) | STO ] , (V |-> B2) STO') = ([ (VL := EL) | STO ] , (V |-> B1) STO') [variant] .
	eq [multi3] : (B1, [ (V := E) | STO ] , (V |-> B2) STO') = ([ skip | STO ] , (V |-> B1) STO') [variant] .
	eq [multi3] : (Y1, [ (V VL := E EL) | STO ] , (V |-> Y2) STO') = ([ (VL := EL) | STO ] , (V |-> Y1) STO') [variant] .
	eq [multi3] : (Y1, [ (V := E) | STO ] , (V |-> Y2) STO') = ([ skip | STO ] , (V |-> Y1) STO') [variant] .
	eq [multi4] : ([ skip | STO ], STO') = (skip, STO') [variant] .
	
	eq [simple1] : (((V := E) ; S) , STO) = (E, ((V := E) ; S) , STO)  [variant] .
	eq [simple2] : (exp(V1), ((V2 := E) ; S) , ((V1 |-> G) STO)) = (G, ((V2 := E) ; S) , ((V1 |-> G) STO)) [variant] .
	eq [simple2] : (exp(V1), ((V2 := E) ; S) , ((V1 |-> B) STO)) = (B, ((V2 := E) ; S) , ((V1 |-> B) STO)) [variant] .
	eq [simple2] : (exp(V1), ((V2 := E) ; S) , ((V1 |-> Y) STO)) = (Y, ((V2 := E) ; S) , ((V1 |-> Y) STO)) [variant] .
	eq [simple2] : (exp(V1) + E1, ((V2 := E2) ; S) , ((V1 |-> G) STO)) = (G + E1, ((V2 := E2) ; S) , ((V1 |-> G) STO)) [variant] .
	eq [simple2] : (exp(V1) - E1, ((V2 := E2) ; S) , ((V1 |-> G) STO)) = (G - E1, ((V2 := E2) ; S) , ((V1 |-> G) STO)) [variant] .
	eq [simple2] : (E1 - exp(V1), ((V2 := E2) ; S) , ((V1 |-> G) STO)) = (E1 - G, ((V2 := E2) ; S) , ((V1 |-> G) STO)) [variant] .
	eq [simple2] : (exp(V1) x E1, ((V2 := E2) ; S) , ((V1 |-> G) STO)) = (G x E1, ((V2 := E2) ; S) , ((V1 |-> G) STO)) [variant] .
	eq [simple3] : (G1, ((V := E) ; S) , ((V |-> G2) STO)) = (S , ((V |-> G1) STO)) [variant] .
	eq [simple3] : (B1, ((V := E) ; S) , ((V |-> B2) STO)) = (S , ((V |-> B1) STO)) [variant] .
	eq [simple3] : (Y1, ((V := E) ; S) , ((V |-> Y2) STO)) = (S , ((V |-> Y1) STO)) [variant] .
	
	eq [simple1] : ((V := E) , STO) = (E, (V := E) , STO)  [variant] .
	eq [simple2] : (exp(V1), (V2 := E) , ((V1 |-> G) STO)) = (G, (V2 := E) , ((V1 |-> G) STO)) [variant] .
	eq [simple2] : (exp(V1), (V2 := E) , ((V1 |-> B) STO)) = (B, (V2 := E) , ((V1 |-> B) STO)) [variant] .
	eq [simple2] : (exp(V1), (V2 := E) , ((V1 |-> Y) STO)) = (Y, (V2 := E) , ((V1 |-> Y) STO)) [variant] .
	eq [simple2] : (exp(V1) + E1, (V2 := E2) , ((V1 |-> G) STO)) = (G + E1, (V2 := E2) , ((V1 |-> G) STO)) [variant] .
	eq [simple2] : (exp(V1) - E1, (V2 := E2) , ((V1 |-> G) STO)) = (G - E1, (V2 := E2) , ((V1 |-> G) STO)) [variant] .
	eq [simple2] : (E1 - exp(V1), (V2 := E2) , ((V1 |-> G) STO)) = (E1 - G, (V2 := E2) , ((V1 |-> G) STO)) [variant] .
	eq [simple2] : (exp(V1) x E1, (V2 := E2) , ((V1 |-> G) STO)) = (G x E1, (V2 := E2) , ((V1 |-> G) STO)) [variant] .
	eq [simple3] : (G1, (V := E) , ((V |-> G2) STO)) = (skip , ((V |-> G1) STO)) [variant] .
	eq [simple3] : (B1, (V := E) , ((V |-> B2) STO)) = (skip , ((V |-> B1) STO)) [variant] .
	eq [simple3] : (Y1, (V := E) , ((V |-> Y2) STO)) = (skip , ((V |-> Y1) STO)) [variant] .
	
	eq [pre1] : (((P | S) ; S1) , STO) = (P , ((P | S) ; S1) , STO) [variant] .
	eq [pre2] : ((exp(V1) eq E), ((P | S) ; S1) , ((V1 |-> G) STO)) = (G eq E, ((P | S) ; S1) , ((V1 |-> G) STO)) [variant] .
	eq [pre2] : ((exp(V1) <= E), ((P | S) ; S1) , ((V1 |-> G) STO)) = (G <= E, ((P | S) ; S1) , ((V1 |-> G) STO)) [variant] .
	eq [pre2] : ((exp(V1) < E), ((P | S) ; S1) , ((V1 |-> G) STO)) = (G < E, ((P | S) ; S1) , ((V1 |-> G) STO)) [variant] .
	eq [pre2] : ((exp(V1) > E), ((P | S) ; S1) , ((V1 |-> G) STO)) = (G > E, ((P | S) ; S1) , ((V1 |-> G) STO)) [variant] .
	eq [pre2] : ((exp(V1) >= E), ((P | S) ; S1) , ((V1 |-> G) STO)) = (G >= E, ((P | S) ; S1) , ((V1 |-> G) STO)) [variant] .
	eq [pre2] : ((exp(V1) <= exp(V2)), ((P | S) ; S1) , ((V1 |-> G) (V2 |-> G1) STO)) = (G <= G1, ((P | S) ; S1) , ((V1 |-> G) (V2 |-> G1) STO)) [variant] .
	eq [pre2] : ((exp(V1) < exp(V2)), ((P | S) ; S1) , ((V1 |-> G) (V2 |-> G1) STO)) = (G < G1, ((P | S) ; S1) , ((V1 |-> G) (V2 |-> G1) STO)) [variant] .
	eq [pre2] : ((exp(V1) > exp(V2)), ((P | S) ; S1) , ((V1 |-> G) (V2 |-> G1) STO)) = (G > G1, ((P | S) ; S1) , ((V1 |-> G) (V2 |-> G1) STO)) [variant] .
	eq [pre2] : ((exp(V1) >= exp(V2)), ((P | S) ; S1) , ((V1 |-> G) (V2 |-> G1) STO)) = (G >= G1, ((P | S) ; S1) , ((V1 |-> G) (V2 |-> G1) STO)) [variant] .
	eq [pre2] : ((E <= exp(V1)), ((P | S) ; S1) , ((V1 |-> G) STO)) = (E <= G, ((P | S) ; S1) , ((V1 |-> G) STO)) [variant] .
	eq [pre2] : ((E < exp(V1)), ((P | S) ; S1) , ((V1 |-> G) STO)) = (E < G, ((P | S) ; S1) , ((V1 |-> G) STO)) [variant] .
	eq [pre2] : ((E > exp(V1)), ((P | S) ; S1) , ((V1 |-> G) STO)) = (E > G, ((P | S) ; S1) , ((V1 |-> G) STO)) [variant] .
	eq [pre2] : ((E >= exp(V1)), ((P | S) ; S1) , ((V1 |-> G) STO)) = (E >= G, ((P | S) ; S1) , ((V1 |-> G) STO)) [variant] .
	eq [pre2] : ((exp(V1) in SN), ((P | S) ; S1) , ((V1 |-> G) STO)) = (G in SN, ((P | S) ; S1) , ((V1 |-> G) STO)) [variant] .
	eq [pre3] : (true, ((P | S) ; S1) , STO) = ((S ; S1) , STO) [variant] .
	eq [pre4] : (false, ((P | S) ; S1) , STO) = (S1 , STO) [variant] .
	
	eq [pre1] : ((P | S) , STO) = (P , (P | S) , STO) [variant] .
	eq [pre2] : ((exp(V1) eq E), (P | S) , ((V1 |-> G) STO)) = (G eq E, (P | S) , ((V1 |-> G) STO)) [variant] .
	eq [pre2] : ((exp(V1) <= E), (P | S) , ((V1 |-> G) STO)) = (G <= E, (P | S) , ((V1 |-> G) STO)) [variant] .
	eq [pre2] : ((exp(V1) < E), (P | S) , ((V1 |-> G) STO)) = (G < E, (P | S) , ((V1 |-> G) STO)) [variant] .
	eq [pre2] : ((exp(V1) > E), (P | S) , ((V1 |-> G) STO)) = (G > E, (P | S) , ((V1 |-> G) STO)) [variant] .
	eq [pre2] : ((exp(V1) >= E), (P | S) , ((V1 |-> G) STO)) = (G >= E, (P | S) , ((V1 |-> G) STO)) [variant] .
	eq [pre2] : ((exp(V1) <= exp(V2)), (P | S) , ((V1 |-> G) (V2 |-> G1) STO)) = (G <= G1, (P | S) , ((V1 |-> G) (V2 |-> G1) STO)) [variant] .
	eq [pre2] : ((exp(V1) < exp(V2)), (P | S) , ((V1 |-> G) (V2 |-> G1) STO)) = (G < G1, (P | S) , ((V1 |-> G) (V2 |-> G1) STO)) [variant] .
	eq [pre2] : ((exp(V1) > exp(V2)), (P | S) , ((V1 |-> G) (V2 |-> G1) STO)) = (G > G1, (P | S) , ((V1 |-> G) (V2 |-> G1) STO)) [variant] .
	eq [pre2] : ((exp(V1) >= exp(V2)), (P | S) , ((V1 |-> G) (V2 |-> G1) STO)) = (G >= G1, (P | S) , ((V1 |-> G) (V2 |-> G1) STO)) [variant] .
	eq [pre2] : ((E <= exp(V1)), (P | S) , ((V1 |-> G) STO)) = (E <= G, (P | S) , ((V1 |-> G) STO)) [variant] .
	eq [pre2] : ((E < exp(V1)), (P | S) , ((V1 |-> G) STO)) = (E < G, (P | S) , ((V1 |-> G) STO)) [variant] .
	eq [pre2] : ((E > exp(V1)), (P | S) , ((V1 |-> G) STO)) = (E > G, (P | S) , ((V1 |-> G) STO)) [variant] .
	eq [pre2] : ((E >= exp(V1)), (P | S) , ((V1 |-> G) STO)) = (E >= G, (P | S) , ((V1 |-> G) STO)) [variant] .
	eq [pre2] : ((exp(V1) in SN), (P | S) , ((V1 |-> G) STO)) = (G in SN, (P | S) , ((V1 |-> G) STO)) [variant] .
	eq [pre3] : (true, P | S , STO) = (S , STO) [variant] .
	eq [pre4] : (false, P | S , STO) = abort [variant] .
	
	rl [bchoice] : S1 [] S2 => S1 .
	
	eq [loop] : (S)^ = (S ; (S ^)) [] skip .
	
	eq [guard1] : (((P ==> S) ; S1) , STO) = (P , ((P ==> S) ; S1) , STO) [variant] .
	eq [guard2] : ((exp(V1) eq E), ((P ==> S) ; S1) , ((V1 |-> G) STO)) = ((G eq E), ((P ==> S) ; S1) , ((V1 |-> G) STO)) [variant] .
	eq [guard2] : ((exp(V1) < E), ((P ==> S) ; S1) , ((V1 |-> G) STO)) = ((G < E), ((P ==> S) ; S1) , ((V1 |-> G) STO)) [variant] .
	eq [guard2] : ((exp(V1) <= E), ((P ==> S) ; S1) , ((V1 |-> G) STO)) = ((G <= E), ((P ==> S) ; S1) , ((V1 |-> G) STO)) [variant] .
	eq [guard2] : ((exp(V1) > E), ((P ==> S) ; S1) , ((V1 |-> G) STO)) = ((G > E), ((P ==> S) ; S1) , ((V1 |-> G) STO)) [variant] .
	eq [guard2] : ((exp(V1) >= E), ((P ==> S) ; S1) , ((V1 |-> G) STO)) = ((G >= E), ((P ==> S) ; S1) , ((V1 |-> G) STO)) [variant] .
	eq [guard2] : ((exp(V1) < exp(V2)), ((P ==> S) ; S1) , ((V1 |-> G) (V2 |-> G1) STO)) = ((G < G1), ((P ==> S) ; S1) , ((V1 |-> G) (V2 |-> G1) STO)) [variant] .
	eq [guard2] : ((exp(V1) <= exp(V2)), ((P ==> S) ; S1) , ((V1 |-> G) (V2 |-> G1) STO)) = ((G <= G1), ((P ==> S) ; S1) , ((V1 |-> G) (V2 |-> G1) STO)) [variant] .
	eq [guard2] : ((exp(V1) > exp(V2)), ((P ==> S) ; S1) , ((V1 |-> G) (V2 |-> G1) STO)) = ((G > G1), ((P ==> S) ; S1) , ((V1 |-> G) (V2 |-> G1) STO)) [variant] .
	eq [guard2] : ((exp(V1) >= exp(V2)), ((P ==> S) ; S1) , ((V1 |-> G) (V2 |-> G1) STO)) = ((G >= G1), ((P ==> S) ; S1) , ((V1 |-> G) (V2 |-> G1) STO)) [variant] .
	eq [guard2] : ((E < exp(V1)), ((P ==> S) ; S1) , ((V1 |-> G) STO)) = ((E < G), ((P ==> S) ; S1) , ((V1 |-> G) STO)) [variant] .
	eq [guard2] : ((E <= exp(V1)), ((P ==> S) ; S1) , ((V1 |-> G) STO)) = ((E <= G), ((P ==> S) ; S1) , ((V1 |-> G) STO)) [variant] .
	eq [guard2] : ((E > exp(V1)), ((P ==> S) ; S1) , ((V1 |-> G) STO)) = ((E > G), ((P ==> S) ; S1) , ((V1 |-> G) STO)) [variant] .
	eq [guard2] : ((E >= exp(V1)), ((P ==> S) ; S1) , ((V1 |-> G) STO)) = ((E >= G), ((P ==> S) ; S1) , ((V1 |-> G) STO)) [variant] .
	eq [guard2] : ((exp(V1) in SN), ((P ==> S) ; S1) , ((V1 |-> G) STO)) = ((G in SN), ((P ==> S) ; S1) , ((V1 |-> G) STO)) [variant] .
	eq [guard3] : (true, ((P ==> S) ; S1) , STO) = ((S ; S1) , STO) [variant] .
	eq [guard4] : (false, ((P ==> S) ; S1) , STO) = (S1, STO) [variant] .
	
	eq [guard1] : ((P ==> S) , STO) = (P , (P ==> S) , STO) [variant] .
	eq [guard2] : ((exp(V1) eq E), (P ==> S) , ((V1 |-> G) STO)) = ((G eq E), (P ==> S) , ((V1 |-> G) STO)) [variant] .
	eq [guard2] : ((exp(V1) < E), (P ==> S) , ((V1 |-> G) STO)) = ((G < E), (P ==> S) , ((V1 |-> G) STO)) [variant] .
	eq [guard2] : ((exp(V1) <= E), (P ==> S) , ((V1 |-> G) STO)) = ((G <= E), (P ==> S) , ((V1 |-> G) STO)) [variant] .
	eq [guard2] : ((exp(V1) > E), (P ==> S) , ((V1 |-> G) STO)) = ((G > E), (P ==> S) , ((V1 |-> G) STO)) [variant] .
	eq [guard2] : ((exp(V1) >= E), (P ==> S) , ((V1 |-> G) STO)) = ((G >= E), (P ==> S) , ((V1 |-> G) STO)) [variant] .
	eq [guard2] : ((exp(V1) < exp(V2)), (P ==> S) , ((V1 |-> G) (V2 |-> G1) STO)) = ((G < G1), (P ==> S) , ((V1 |-> G) (V2 |-> G1) STO)) [variant] .
	eq [guard2] : ((exp(V1) <= exp(V2)), (P ==> S) , ((V1 |-> G) (V2 |-> G1) STO)) = ((G <= G1), (P ==> S) , ((V1 |-> G) (V2 |-> G1) STO)) [variant] .
	eq [guard2] : ((exp(V1) > exp(V2)), (P ==> S) , ((V1 |-> G) (V2 |-> G1) STO)) = ((G > G1), (P ==> S) , ((V1 |-> G) (V2 |-> G1) STO)) [variant] .
	eq [guard2] : ((exp(V1) >= exp(V2)), (P ==> S) , ((V1 |-> G) (V2 |-> G1) STO)) = ((G >= G1), (P ==> S) , ((V1 |-> G) (V2 |-> G1) STO)) [variant] .
	eq [guard2] : ((E < exp(V1)), (P ==> S) , ((V1 |-> G) STO)) = ((E < G), (P ==> S) , ((V1 |-> G) STO)) [variant] .
	eq [guard2] : ((E <= exp(V1)), (P ==> S) , ((V1 |-> G) STO)) = ((E <= G), (P ==> S) , ((V1 |-> G) STO)) [variant] .
	eq [guard2] : ((E > exp(V1)), (P ==> S) , ((V1 |-> G) STO)) = ((E > G), (P ==> S) , ((V1 |-> G) STO)) [variant] .
	eq [guard2] : ((E >= exp(V1)), (P ==> S) , ((V1 |-> G) STO)) = ((E >= G), (P ==> S) , ((V1 |-> G) STO)) [variant] .
	eq [guard2] : ((exp(V1) in SN), (P ==> S) , ((V1 |-> G) STO)) = ((G in SN), (P ==> S) , ((V1 |-> G) STO)) [variant] .
	eq [guard3] : (true, (P ==> S) , STO) = (S , STO) [variant] .
	eq [guard4] : (false, (P ==> S) , STO) = (skip, STO) [variant] .
	
	rl [uchoice] : (@ PH . S), STO => (S [ G / PH ]), STO [nonexec] .
	rl [uchoice] : (@ PH . S), STO => (S [ B / PH ]), STO [nonexec] .
	
	eq [repl-gnat] : G1 [ G2 / PH ] = G1 .
	eq [repl-gnat] : G [ B / PH ] = B .
	eq [repl-gbool1] : B1 [ B2 / PH ] = B1 .
	eq [repl-gbool2] : B [ G / PH ] = B .	
	eq [repl-simple] : (V := E) [ G / PH ] = V := ( E [ G / PH ] ) .
	eq [repl-simple] : (V := E) [ B / PH ] = V := ( E [ B / PH ] ) .	
	eq [repl-guarded-subst] : (P ==> S) [ G / PH ] = (P [ G / PH ]) ==> (S [ G / PH]) . 
	eq [repl-guarded-subst] : (P ==> S) [ B / PH ] = (P [ B / PH ]) ==> (S [ B / PH]) . 
	eq [repl-pre-subst] : (P | S) [ G / PH ] = (P [ G / PH ]) | (S [ G / PH]) . 
	eq [repl-pre-subst] : (P | S) [ B / PH ] = (P [ B / PH ]) | (S [ B / PH]) . 
	eq [repl-ph-gnat] : PH [ G / PH ] = G .
	eq [repl-ph-gbool] : PH [ B / PH ] = B .
	eq [repl-and] : (P1 and P2) [ B / PH ] = (P1 [ B / PH]) and (P2 [ B / PH]) .
	eq [repl-and] : (P1 and P2) [ G / PH ] = (P1 [ G / PH]) and (P2 [ G / PH]) .
	eq [repl-or] : (P1 or P2) [ B / PH ] = (P1 [ B / PH]) or (P2 [ B / PH]) .
	eq [repl-or] : (P1 or P2) [ G / PH ] = (P1 [ G / PH]) or (P2 [ G / PH]) .
	eq [repl-eq] : (E1 eq E2) [ G / PH ] = (E1 [ G / PH ]) eq (E2 [ G / PH ]) .
	eq [repl-equals] : (PH eq E) [ G / PH ] = G eq E .
	eq [repl-ph-sum] : (PH + E) [ G / PH ] = G + (E [ G / PH ]) .
	eq [repl-ph-tim] : (PH x E) [ G / PH ] = G x (E [ G / PH ]) .
	eq [repl-ph-sub] : (PH - E) [ G / PH ] = G - (E [ G / PH ]) .
	eq [repl-ph-sub] : (E - PH) [ G / PH ] = (E [ G / PH ]) - G .
	eq [repl-leq] : (PH <= E) [ G / PH ] = G <= (E [ G / PH ]) .
	eq [repl-leq] : (E <= PH) [ G / PH ] = (E [ G / PH ]) <= G .
	eq [repl-geq] : (PH >= E) [ G / PH ] = G >= (E [ G / PH ]) .
	eq [repl-geq] : (E >= PH) [ G / PH ] = (E [ G / PH ]) >= G .
	eq [repl-less] : (PH < E) [ G / PH ] = G < (E [ G / PH ]) .
	eq [repl-less] : (E < PH) [ G / PH ] = (E [ G / PH ]) < G .
	eq [repl-great] : (PH > E) [ G / PH ] = G > (E [ G / PH ]) .
	eq [repl-great] : (E > PH) [ G / PH ] = (E [ G / PH ]) > G .
	eq [repl-in] : (PH in SN) [ G / PH ] = G in SN .
	eq [repl-in] : (PH in A) [ G / PH ] = G in A .
	eq [repl-array] : (A(PH) := E) [ G / PH ] = A(G) := (E [ G / PH ]) .
	eq [repl-seq-comp] : (S1 ; S2) [ G / PH ] = ((S1 [ G / PH ]) ; (S2 [ G / PH ])) .
	eq [repl-seq-comp] : (S1 ; S2) [ B / PH ] = ((S1 [ B / PH ]) ; (S2 [ B / PH ])) .
	eq [repl-while] : (S ^) [ G / PH] = ( S [ G / PH ] ) ^ .
	eq [repl-while] : (S ^) [ B / PH] = ( S [ B / PH ] ) ^ .
endm)

***(mod debug is
inc GSL-SEMANTICS .

op p : -> Predicate .
ops s t : -> Substitution .
op h : -> PlaceHolder .
ops v u x y : -> Variable .
op A : -> Array{Variable,Naturals} .
op `(_eq_`) : Variable Variable -> Predicate .
op a : -> GSym .

vars V U : Variable .

eq A = (x,0) ; (y,s(0)) ; (v,s^2(0)) .
eq (V eq U) = exp(V) eq exp(U) .
endm)

(mod SIMPLIFIED-AMN-4-OPERATIONS is
    inc GSL-SEMANTICS .
	sort NeSubstitutionSet .
	subsort Substitution < NeSubstitutionSet .

	op BEGIN_END : Substitution -> Substitution .
	op PRE_THEN_END : Predicate Substitution -> Substitution .
	op IF_THEN_ELSE_END : Predicate Substitution Substitution -> Substitution .
	op IF_THEN_END : Predicate Substitution -> Substitution .
	op _:=`bool`(_`) : Variable Predicate -> Substitution .
	op _OR_ : NeSubstitutionSet NeSubstitutionSet -> NeSubstitutionSet [assoc comm] .
	op CHOICE_END : NeSubstitutionSet -> Substitution .
	op ANY_WHERE_THEN_END : PlaceHolder Predicate Substitution -> Substitution .
	op WHILE_DO_END : Predicate Substitution -> Substitution .
	op _||_ : Substitution Substitution -> Substitution [assoc comm] .
	op SELECT_THEN_END : Predicate Substitution -> Substitution .

	vars S T U : Substitution . var SS : NeSubstitutionSet . vars P P1 P2 : Predicate . var X : PlaceHolder .
	vars V V1 V2 : Variable . vars E1 E2 : Expression .
	var VL : VarList . var EL : ExpList .

	eq BEGIN S END = S .
	eq PRE P THEN S END = (P | S) .
	eq IF P THEN S ELSE T END = (P ==> S) [] (neg(P) ==> T) .
	eq IF P THEN S END = IF P THEN S ELSE skip END .
	eq V := bool ( P ) = IF P THEN (V := true) ELSE (V := false) END .
	eq CHOICE SS END = SS .
	eq S OR T = S [] T .	
	eq S OR (T OR SS) = S [] (T OR SS) .
	eq ANY X WHERE P THEN S END = (@ X . (P ==> S)) .
	eq WHILE P DO S END = ((P ==> S)^);(neg(P) ==> skip) .
	eq SELECT P THEN S END = (P ==> S) .

	eq (V1 := E1) || (V2 := E2) = (V1 (V2)) := (E1 (E2)) .
	eq (V1 := E1) || (VL := EL) = (V1 (VL)) := (E1 (EL)) .
	eq T || (P | S) = P | (T || S) .
	eq S || (T [] U) = (S || T) [] (S || U) .
	eq S || (T [] (U [] SS)) = (S || T) [] (S || (U [] SS)) .
	eq S || (P ==> T) = P ==> (S || T) .
	eq T || (@ X . (P ==> S)) = (@ X . (P ==> (T || S))) .
	eq skip || S = S .
	eq S ; skip = S .
	eq skip ; S = S .
endm)

(mod B-USER-INTERFACE is 
	inc SIMPLIFIED-AMN-4-OPERATIONS .
	---op `(_eq_`) : Variable Variable -> Predicate .
	op `(_eq_`) : Variable Expression -> Predicate .
	---op `(_eq_`) : Expression Variable -> Predicate .
	---op `(_+_`) : Variable Variable -> Expression .
	---op `(_+_`) : Variable Expression -> Expression .
	---op `(_+_`) : Expression Variable -> Expression .
	---op `(_-_`) : Variable Variable -> Expression .
	---op `(_-_`) : Variable Expression -> Expression .
	---op `(_-_`) : Expression Variable -> Expression .
	---op `(_x_`) : Variable Variable -> Expression .
	---op `(_x_`) : Variable Expression -> Expression .
	---op `(_x_`) : Expression Variable -> Expression .
	
	var V : Variable . var E : Expression .
	eq (V eq E) = (exp(V) eq E) .
endm)

(mod MUTEX-SIMPLE is
	inc B-USER-INTERFACE .
	
	op protocol : Array{Variable,Naturals} -> Substitution .
	ops stateP1 stateP2 stateP3 criticSection : -> Variable .
	op processes : -> Array{Variable,Naturals} .
	op process : -> PlaceHolder .
	ops idle wait crit : -> GSym .
	
	var procSet : Array{Variable,Naturals} .
	
	eq processes = (stateP1,0) ; (stateP2,s(0)) .
	
	eq protocol(procSet) =
	BEGIN
		WHILE (true) DO (
			ANY process WHERE (process in procSet) THEN (
			SELECT (procSet(process) eq idle) THEN (stateP1 := wait) END
			OR
			SELECT ((procSet(process) eq wait) and (criticSection eq 0)) THEN ((procSet(process) := crit) ; (criticSection := s(0))) END
			OR
			SELECT (procSet(process) eq crit) THEN ((procSet(process) := idle) ; (criticSection := 0)) END
			) END
		)END
	END .
endm)

(mod MUTEX-SIMPLE-SAT is
	inc MUTEX-SIMPLE .
	inc SYMBOLIC-CHECKER .
	subsort Conf < State .
	
	ops idleP1? waitP1? critP1? : -> Prop .
	ops idleP2? waitP2? critP2? : -> Prop .
	var S : Substitution . var STO : Store . var Y : GSym .
	
	eq S, (stateP1 |-> Y) STO |= idleP1? = if (Y == idle) then true else false fi [variant] .
	eq S, (stateP1 |-> Y) STO |= waitP1? = if (Y == wait) then true else false fi [variant] .
	eq S, (stateP1 |-> Y) STO |= critP1? = if (Y == crit) then true else false fi [variant] .
	
	eq S, (stateP2 |-> Y) STO |= idleP2? = if (Y == idle) then true else false fi [variant] .
	eq S, (stateP2 |-> Y) STO |= waitP2? = if (Y == wait) then true else false fi [variant] .
	eq S, (stateP2 |-> Y) STO |= critP2? = if (Y == crit) then true else false fi [variant] .
endm)

(lmc protocol(processes), STO:Store |= [] ~(critP1? /\ critP2?) .)
(lmc protocol(processes), STO:Store |= [] (waitP1? -> <> critP1?) /\ (waitP2? -> <> critP2?) .)

(mod LAMPORT-BAKERY is
	inc B-USER-INTERFACE .
	
	op protocol : Array{Variable,Naturals} Array{Variable,Naturals} -> Substitution .
	ops stateP1 stateP2 dist server ticket1 ticket2 : -> Variable .
	op processes : -> Array{Variable,Naturals} .
	op tickets : -> Array{Variable,Naturals} .
	op process : -> PlaceHolder .
	ops idle wait crit : -> GSym .
	
	var procSet : Array{Variable,Naturals} . var tickSet : Array{Variable,Naturals} .
	
	eq processes = (stateP1,0) ; (stateP2,s(0)) .
	eq tickets = (ticket1,0) ; (ticket2,s(0)) .
	
	eq protocol(procSet,tickSet) =
	BEGIN
		WHILE (true) DO (
			ANY process WHERE (process in procSet) THEN (
			SELECT (procSet(process) eq idle) THEN ((tickSet(process) := exp(dist)) ; ((procSet(process) := wait) ; (dist := exp(dist) + s(0)))) END
			OR
			SELECT ((procSet(process) eq wait) and (tickSet(process) eq exp(server))) THEN (procSet(process) := crit) END
			OR
			SELECT (procSet(process) eq crit) THEN ((procSet(process) := idle) ; (server := exp(server) + s(0))) END
			) END
		)END
	END .
endm)

(mod BAKERY-SAT is
	inc LAMPORT-BAKERY .
	inc SYMBOLIC-CHECKER .
	subsort Conf < State .
	
	ops idleP1? waitP1? critP1? : -> Prop .
	ops idleP2? waitP2? critP2? : -> Prop .
	var S : Substitution . var STO : Store . var Y : GSym .
	
	eq S, (stateP1 |-> Y) STO |= idleP1? = if (Y == idle) then true else false fi [variant] .
	eq S, (stateP1 |-> Y) STO |= waitP1? = if (Y == wait) then true else false fi [variant] .
	eq S, (stateP1 |-> Y) STO |= critP1? = if (Y == crit) then true else false fi [variant] .
	
	eq S, (stateP2 |-> Y) STO |= idleP2? = if (Y == idle) then true else false fi [variant] .
	eq S, (stateP2 |-> Y) STO |= waitP2? = if (Y == wait) then true else false fi [variant] .
	eq S, (stateP2 |-> Y) STO |= critP2? = if (Y == crit) then true else false fi [variant] .
endm)

(lmc protocol(processes,tickets), STO:Store |= [] ~(critP1? /\ critP2?) .)
(lmc protocol(processes,tickets), STO:Store |= [] (waitP1? -> <> critP1?) /\ (waitP2? -> <> critP2?) .)